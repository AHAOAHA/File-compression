# 文件压缩

### 压缩

* 受先创建出一个hash表，用来表示每个字符出现的次数&编码
* 遍历文件内容，统计出文件各个字符出现的字数，记录到创建好的hash表内。
* 创建一个小堆。
* 遍历hash表，将文件中出现过的字符及其信息保存至创建好的优先级队列中。
* 通过优先级队列创建huffman树。
  * 拿出堆顶的一个节点，保存至临时变量left中。
  * 删除堆定的节点。
  * 再从堆顶拿出一个节点，保存至临时变量right中。
  * 删除堆定的节点。
  * 通过临时变量left&right保存的节点相加，创建一个新的节点。
  * 将创建好的新节点添加进小堆中。
  * 当堆中仅剩一个节点时，退出循环。
  * 将最后一个节点的地址赋给_root。即创建好了huffman树。
* 通过创建好的Huffman树生成字符编码，并将字符对应的编码存储进hash表中对应字符的编码位置。

### 解压缩

* 先以写方式打开新的解压文件，命名后缀为.unhuffman。
* 在开始解压文件之前，先要重新构建huffman树，因为压缩与解压不能同时操作，所以需要在开始压缩之前，将文件中出现过的字符信号存储在压缩文件的头部，并以一个标志结束。
* 从压缩文件的头部读取出源文件出现过的字符信息，重新存入_hashInfo桶中，当读到结束标志时，表明从结束标志向后的内容为源文件的\_code。
* 使用_hashInfo重新构建huffman树。
* 以char为基准，读取出8字符的\_code，从构建好的huffman树的头部开始，如果遇到1，则指针向左，如果遇到0则指针向右，当指针的左子树&右子树都为空指针时，则说明该节点内存储的值为源文件的字符，即将该字符写入新的解压文件中。
* 根节点中的count即为源文件中所有字符的个数，当解压文件时，恢复出一个文件就让count的值减1，当count的值为0时，则说明文件恢复完成，此时即可退出。

### C++文件二进制读写抛出异常问题

#### 问题描述

当我在对文件进行压缩操作时，源文件中出现的字符信息（字符&字符出现次数&**字符特定编码**）都以二进制读写的方式存进了压缩文件的头部，以一个_count = 0的节点作为结尾，但是当我在对文件进行重新以二进制方式读取时，想要将源文件出现过的字符信息重新读取出来时，在程序的结尾部分，总会抛出不明指向的异常。

字符信息结构体如下：

```c++
struct CharInfo
{
    char _ch;
    int _count;
    string _code;
};
```

#### 问题原因

查阅各种资料后得知，只有POD类型才可以安全的写入到文件中再重新读取回来，而在这里STL中的string并不是POD类型，string是一个复杂的类，内部含有指向new的对象的指针，当一个string使用结束时，它会调用string类的析构函数，在析构函数中会将这个指针指向的堆空间释放掉，而在这里，文件开始压缩之前，我使用二进制读写的方式将string类型存储进了压缩文件的头部，而在解压缩时，我又定义了一个string类型的变量，将从压缩文件头部读出的string数据直接以二进制方式写入新的string中，此时会有两种情况：

* 一是此时该string对象中的指针指向的堆空间并没有被释放，那么现在就会有两个string类指向了同一个完全相同的堆空间，每一个string对象使用完成时都会调用自己的析构函数来释放这一段空间，那么同一段堆空间怎么可以被释放两次呢？
* 而时此时该string对象中的指针指向的堆空间已经被释放，一段空间已经被释放当然就不可以再继续使用。

#### 解决方法

重新定义字符信息结构体，结构体如下：

```c++
struct ChInfo
{
    char _ch;
    char _count;
};
```

不再记录字符的特定编码值，在解压缩函数中重新生成字符的特定编码。