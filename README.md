# 文件压缩

### 压缩

* 受先创建出一个hash表，用来表示每个字符出现的次数&编码
* 遍历文件内容，统计出文件各个字符出现的字数，记录到创建好的hash表内。
* 创建一个小堆。
* 遍历hash表，将文件中出现过的字符及其信息保存至创建好的优先级队列中。
* 通过优先级队列创建huffman树。
  * 拿出堆顶的一个节点，保存至临时变量left中。
  * 删除堆定的节点。
  * 再从堆顶拿出一个节点，保存至临时变量right中。
  * 删除堆定的节点。
  * 通过临时变量left&right保存的节点相加，创建一个新的节点。
  * 将创建好的新节点添加进小堆中。
  * 当堆中仅剩一个节点时，退出循环。
  * 将最后一个节点的地址赋给_root。即创建好了huffman树。
* 通过创建好的Huffman树生成字符编码，并将字符对应的编码存储进hash表中对应字符的编码位置。

### 解压缩

* 先以写方式打开新的解压文件，命名后缀为.unhuffman。
* 在开始解压文件之前，先要重新构建huffman树，因为压缩与解压不能同时操作，所以需要在开始压缩之前，将文件中出现过的字符信号存储在压缩文件的头部，并以一个标志结束。
* 从压缩文件的头部读取出源文件出现过的字符信息，重新存入_hashInfo桶中，当读到结束标志时，表明从结束标志向后的内容为源文件的\_code。
* 使用_hashInfo重新构建huffman树。
* 以char为基准，读取出8字符的\_code，从构建好的huffman树的头部开始，如果遇到1，则指针向左，如果遇到0则指针向右，当指针的左子树&右子树都为空指针时，则说明该节点内存储的值为源文件的字符，即将该字符写入新的解压文件中。
* 根节点中的count即为源文件中所有字符的个数，当解压文件时，恢复出一个文件就让count的值减1，当count的值为0时，则说明文件恢复完成，此时即可退出。