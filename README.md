# 文件压缩

### 压缩

#### Step1

遍历源文件的内容，对源文件中出现的字符次数以及字符进行统计。

>  使用hash表来存储统计结果，hash桶key值对应字符在ASCII码表中的数值。该步对字符出现的次数进行统计并记录。

#### Step2

根据hash表中的数据，将字符出现次数作为字符的权重，构建Huffman树。因为此处将要以HUffman树为基本，统计出每个字符在Huffman树中的特定编码，所以为了提高效率，出现次数多的字符，应该尽可能的处于Huffman树的顶端。

> 基于字符出现的次数创建优先级队列，将文件中出现过的字符及其信息保存进优先级队列中。通过优先级队列创建出Huffman树。
>
> 每次从优先级队列中出队列两个字符节点，为这两个字符节点创建出父亲节点，重新将父亲节点入队列，直到优先级队列中只剩下一个节点，该节点就应该作为Huffman树的root节点。

#### Step3

通过创建好的Huffman树生成字符编码，并将字符对应的编码存储进hash表中对应字符的编码位置。

> 通过Huffman树生成字符的特定编码，使用string记录字符的编码，从root节点开始，向右子树走即为1，向左子树走即为0。

#### Step4

记录字符的特定编码。

> 通过上面的步骤，可是使用0/1的序列来表示文件中出现过的字符，重新遍历文件中出现过的字符，并创建新文件，记录每个文件的编码，当编码到8位时，将该8位编码所对应的新字符写入新文件，当文件遍历至结尾时，即表明文件压缩过程完成，新文件即为压缩文件。

#### NOTE

记录文件类型。

> 将文件的类型记录在压缩文件的开始位置，采用 字节数+文件类型字符串 的方式记录。

记录文件中出现的字符&出现频率。

> 将文件中出现的字符以及出现频率存储进压缩文件中，位于文件类型之后，方便解压缩时读取。此处没有存储字符的特定编码。以一个出现次数为0的节点作为结束标志。

### 解压缩

#### Step1

提取文件类型，并生成解压文件。

> 从压缩文件的前4字节提取到文件名所占用的字节数，提取文件类型并根据传入的文件名生成新的解压文件名，并以二进制写入的方式打开。

#### Step2

重建Huffman树。

> 从压缩文件中读取源文件中出现过的字符&字符出现次数，根据压缩时的方式重建huffman树并重新生成字符的特定编码。

#### Step3

恢复文件。

> 以char为基准，读取出8字符的\_code，从构建好的huffman树的头部开始，如果遇到1，则指针向左，如果遇到0则指针向右，当指针的左子树&右子树都为空指针时，则说明该节点内存储的值为源文件的字符，即将该字符写入新的解压文件中。
>
> 根节点中的count即为源文件中所有字符的个数，当解压文件时，恢复出一个文件就让count的值减1，当count的值为0时，则说明文件恢复完成，此时即可退出。

### C++文件二进制读写抛出异常问题

#### 问题描述

当我在对文件进行压缩操作时，源文件中出现的字符信息（字符&字符出现次数&**字符特定编码**）都以二进制读写的方式存进了压缩文件的头部，以一个_count = 0的节点作为结尾，但是当我在对文件进行重新以二进制方式读取时，想要将源文件出现过的字符信息重新读取出来时，在程序的结尾部分，总会抛出不明指向的异常。

字符信息结构体如下：

```c++
struct CharInfo
{
    char _ch;
    int _count;
    string _code;
};
```

#### 问题原因

查阅各种资料后得知，只有POD类型才可以安全的写入到文件中再重新读取回来，而在这里STL中的string并不是POD类型，string是一个复杂的类，内部含有指向new的对象的指针，当一个string使用结束时，它会调用string类的析构函数，在析构函数中会将这个指针指向的堆空间释放掉，而在这里，文件开始压缩之前，我使用二进制读写的方式将string类型存储进了压缩文件的头部，而在解压缩时，我又定义了一个string类型的变量，将从压缩文件头部读出的string数据直接以二进制方式写入新的string中，此时会有两种情况：

* 一是此时该string对象中的指针指向的堆空间并没有被释放，那么现在就会有两个string类指向了同一个完全相同的堆空间，每一个string对象使用完成时都会调用自己的析构函数来释放这一段空间，那么同一段堆空间怎么可以被释放两次呢？
* 而时此时该string对象中的指针指向的堆空间已经被释放，一段空间已经被释放当然就不可以再继续使用。

#### 解决方法

重新定义字符信息结构体，结构体如下：

```c++
struct ChInfo
{
    char _ch;
    char _count;
};
```

不再记录字符的特定编码值，在解压缩函数中重新生成字符的特定编码。

